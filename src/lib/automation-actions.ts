'use server';

import { prisma } from './prisma';
import { revalidatePath } from 'next/cache';
import { createTask } from './task-actions';
// import { sendEmail } from './email-actions'; // Assuming this exists or will be created

// --- CRUD ---

export async function createAutomationRule(pipelineId: string, data: {
    name: string;
    triggerType: string;
    triggerConfig: any;
    actionType: string;
    actionConfig: any;
}) {
    try {
        const rule = await prisma.automationRule.create({
            data: {
                pipelineId,
                name: data.name,
                triggerType: data.triggerType,
                triggerConfig: JSON.stringify(data.triggerConfig),
                actionType: data.actionType,
                actionConfig: JSON.stringify(data.actionConfig),
                active: true
            }
        });

        revalidatePath('/crm/pipelines/settings');
        return { success: true, rule };
    } catch (error: any) {
        console.error('Error creating automation rule:', error);
        return { success: false, error: error.message };
    }
}

export async function getPipelineAutomations(pipelineId: string) {
    try {
        const rules = await prisma.automationRule.findMany({
            where: { pipelineId },
            orderBy: { createdAt: 'desc' }
        });
        return rules;
    } catch (error) {
        console.error('Error fetching automations:', error);
        return [];
    }
}

export async function deleteAutomationRule(ruleId: string) {
    try {
        await prisma.automationRule.delete({
            where: { id: ruleId }
        });
        revalidatePath('/crm/pipelines/settings');
        return { success: true };
    } catch (error: any) {
        console.error('Error deleting automation rule:', error);
        return { success: false, error: error.message };
    }
}

// --- ENGINE ---

export async function triggerAutomations(event: 'STAGE_ENTER' | 'CARD_CREATED', payload: {
    pipelineId: string;
    stageId: string;
    opportunityId: string;
    userId: string; // Who triggered it
    tenantId: string;
}) {
    console.log(`[Automation] Triggered: ${event}`, payload);

    try {
        // 1. Find matching rules
        const rules = await prisma.automationRule.findMany({
            where: {
                pipelineId: payload.pipelineId,
                triggerType: event,
                active: true
            }
        });

        console.log(`[Automation] Found ${rules.length} rules`);

        // 2. Execute rules
        for (const rule of rules) {
            const triggerConfig = JSON.parse(rule.triggerConfig);
            const actionConfig = JSON.parse(rule.actionConfig);

            // Check conditions (e.g. specific stage)
            if (triggerConfig.stageId && triggerConfig.stageId !== payload.stageId) {
                continue;
            }

            console.log(`[Automation] Executing rule: ${rule.name}`);

            // Execute Action
            if (rule.actionType === 'CREATE_TASK') {
                await createTask({
                    title: actionConfig.title || 'Automated Task',
                    description: `Generated by automation: ${rule.name}`,
                    dueDate: new Date(Date.now() + 24 * 60 * 60 * 1000), // +1 day default
                    assignedToId: payload.userId, // Assign to triggerer for now
                    tenantId: payload.tenantId,
                    // Link to opportunity if we had that relation in Task, for now just description
                });
            } else if (rule.actionType === 'SEND_EMAIL') {
                // Placeholder for email sending
                console.log(`[Automation] Would send email: ${actionConfig.subject}`);
                // await sendEmail(...)
            }
        }
    } catch (error) {
        console.error('[Automation] Error executing automations:', error);
    }
}
